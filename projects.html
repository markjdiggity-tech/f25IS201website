<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <title>Mark Jones;</title>
    <!-- Favicon-->
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
    <!-- Custom Google font-->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@100;200;300;400;500;600;700;800;900&amp;display=swap"
        rel="stylesheet" />
    <!-- Bootstrap icons-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css" rel="stylesheet" />
    <!-- Core theme CSS (includes Bootstrap)-->
    <link href="css/styles.css" rel="stylesheet" />
    <link href="css/mystyles.css" rel="stylesheet" />
    <!-- Game CSS -->
    <style>
        #game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            padding: 20px;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 4px solid #333;
        }

        #game-container canvas {
            display: block;
            background: linear-gradient(to bottom, #0f172a 0%, #1e293b 60%, #334155 100%);
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .scoreboard {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        .p1-score {
            color: #FDB927;
        }

        .p2-score {
            color: #CE1141;
        }

        .timer {
            font-size: 40px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 20px;
            border-radius: 10px;
        }

        .controls-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
        }

        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 4px 4px 0px #000;
            display: none;
            text-align: center;
            z-index: 10;
        }

        .pop-anim {
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0.1);
                opacity: 0;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .fire-text {
            color: #FF4500;
            text-shadow: 0 0 10px #FFD700, 2px 2px 0 #000;
        }

        .restart-msg {
            font-size: 24px;
            margin-top: 20px;
            display: block;
            color: #aaa;
        }
    </style>
</head>

<body class="d-flex flex-column h-100 bg-light">
    <main class="flex-shrink-0">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light bg-white py-3">
            <div class="container px-5">
                <a class="navbar-brand" href="index.html"><span class="fw-bolder text-primary">Mark Jones</span></a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                    aria-expanded="false" aria-label="Toggle navigation"><span
                        class="navbar-toggler-icon"></span></button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav ms-auto mb-2 mb-lg-0 small fw-bolder">
                        <li class="nav-item"><a class="nav-link" href="index.html">Home</a></li>
                        <li class="nav-item"><a class="nav-link" href="resume.html">Resume</a></li>
                        <li class="nav-item"><a class="nav-link" href="projects.html">Game</a></li>
                        <li class="nav-item"><a class="nav-link" href="contact.html">Scratch</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Projects Section-->
        <section class="py-5">
            <div class="container px-5 mb-5">
                <div class="text-center mb-5">
                    <h1 class="display-5 fw-bolder mb-0"><span class="text-gradient d-inline">Game</span></h1>
                </div>

                <div id="game-wrapper">
                    <div id="game-container">
                        <canvas id="gameCanvas"></canvas>
                        <div id="ui-layer">
                            <div class="scoreboard">
                                <div class="p1-score">LEBRON: <span id="score-p1">0</span></div>
                                <div class="timer" id="timer">02:00</div>
                                <div class="p2-score">JORDAN: <span id="score-p2">0</span></div>
                            </div>
                            <div id="message-overlay">BOOMSHAKALAKA!</div>
                            <div class="controls-hint">
                                ARROWS: Move &nbsp;|&nbsp; Z: Shoot / Dunk / Jump &nbsp;|&nbsp; X: Steal
                            </div>
                        </div>
                    </div>
                </div>

        </section>
    </main>

    <!-- Footer-->
    <footer class="bg-white py-4 mt-auto">
        <div class="container px-5">
            <div class="row align-items-center justify-content-between flex-column flex-sm-row">
                <div class="col-auto">
                    <div class="small m-0">Copyright &copy; Mark Jones 2025</div>
                </div>
                <div class="col-auto">
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap core JS-->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Core theme JS-->
    <script src="js/scripts.js"></script>

    <!-- Game Script -->
    <script>
                        /**
                         * ARCADE BASKETBALL: LEBRON VS JORDAN
                         * Fixed implementation
                         */

                        // --- Constants & Setup ---
                        const canvas = document.getElementById('gameCanvas');
                        const ctx = canvas.getContext('2d');
                        const GAME_WIDTH = 800;
                        const GAME_HEIGHT = 500;
                        const GRAVITY = 0.6;
                        const FRICTION = 0.85;
                        const GROUND_Y = 420;

                        canvas.width = GAME_WIDTH;
                        canvas.height = GAME_HEIGHT;

                        const KEYS = {};
                        document.addEventListener('keydown', e => KEYS[e.code] = true);
                        document.addEventListener('keyup', e => KEYS[e.code] = false);

                        // --- Game State ---
                        const state = {
                            p1Score: 0,
                            p2Score: 0,
                            timeLeft: 120,
                            gameOver: false,
                            isScoring: false, // Pauses gameplay during celebration
                            particles: [],
                            camera: { x: 0, y: 0 },
                            screenShake: 0
                        };

                        // --- Classes ---

                        class Particle {
                            constructor(x, y, color, speed, life) {
                                this.x = x;
                                this.y = y;
                                this.color = color;
                                this.vx = (Math.random() - 0.5) * speed;
                                this.vy = (Math.random() - 0.5) * speed;
                                this.life = life;
                                this.maxLife = life;
                            }
                            update() {
                                this.x += this.vx;
                                this.y += this.vy;
                                this.life--;
                            }
                            draw(ctx) {
                                ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
                                ctx.fillStyle = this.color;
                                ctx.fillRect(this.x, this.y, 4, 4);
                                ctx.globalAlpha = 1;
                            }
                        }

                        class Ball {
                            constructor() {
                                this.x = GAME_WIDTH / 2;
                                this.y = 200;
                                this.vx = 0;
                                this.vy = 0;
                                this.radius = 12;
                                this.owner = null;
                                this.isShot = false;
                                this.onFire = false;
                            }

                            update() {
                                // Fire effect
                                if (this.onFire && Math.random() > 0.5) {
                                    state.particles.push(new Particle(this.x, this.y, Math.random() > 0.5 ? '#FF4500' : '#FFD700', 5, 20));
                                }

                                if (this.owner) {
                                    this.x = this.owner.x + (this.owner.facingRight ? 20 : -20);
                                    this.y = this.owner.y - 10;
                                    this.vx = this.owner.vx;
                                    this.vy = this.owner.vy;
                                    this.isShot = false;
                                } else {
                                    // Physics
                                    this.x += this.vx;
                                    this.y += this.vy;
                                    this.vy += GRAVITY * 0.5;

                                    // Bounce Floor
                                    if (this.y + this.radius > GROUND_Y) {
                                        this.y = GROUND_Y - this.radius;
                                        this.vy *= -0.7;
                                        this.vx *= 0.95;
                                        if (Math.abs(this.vy) < 2) this.vy = 0;
                                    }

                                    // Walls
                                    if (this.x < 0) { this.x = 0; this.vx *= -0.8; }
                                    if (this.x > GAME_WIDTH) { this.x = GAME_WIDTH; this.vx *= -0.8; }

                                    // Hoop collisions
                                    hoops.forEach(hoop => {
                                        // Rim collision logic (simplified box)
                                        // Hitting the rim from the side/bottom
                                        if (this.x > hoop.x - 5 && this.x < hoop.x + 45 && Math.abs(this.y - hoop.y) < 15) {
                                            this.vy *= -0.8;
                                            this.vx *= -0.8;
                                            // Prevent sticking
                                            if (Math.abs(this.y - hoop.y) < 5) this.y -= 5;
                                        }

                                        // Score detection
                                        if (this.vy > 0 &&
                                            this.x > hoop.x + 10 && this.x < hoop.x + 30 &&
                                            this.y > hoop.y && this.y < hoop.y + 30 && !this.owner && !state.isScoring) {

                                            if (!hoop.scoredRecently) {
                                                // Pass score to the hoop's "owner" opponent (If left hoop, P2 scores)
                                                scorePoint(hoop.isLeft ? 2 : 1);
                                                hoop.scoredRecently = true;
                                                // Don't reset scoredRecently here, resetPos handles the flow
                                            }
                                        }
                                    });
                                }
                            }

                            draw(ctx) {
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                ctx.fillStyle = this.onFire ? '#FF4500' : '#d35400';
                                ctx.fill();
                                ctx.strokeStyle = '#2c3e50';
                                ctx.lineWidth = 2;
                                ctx.stroke();

                                ctx.beginPath();
                                ctx.moveTo(this.x - this.radius, this.y);
                                ctx.lineTo(this.x + this.radius, this.y);
                                ctx.stroke();
                            }
                        }

                        class Player {
                            constructor(id, name, color, x, stats) {
                                this.id = id;
                                this.name = name;
                                this.color = color;
                                this.startX = x;
                                this.x = x;
                                this.y = GROUND_Y;
                                this.vx = 0;
                                this.vy = 0;
                                this.width = 40;
                                this.height = 80;
                                this.isGrounded = true;
                                this.facingRight = id === 1;

                                // Stats
                                this.stats = stats;
                                this.speed = stats.speed;
                                this.jumpForce = stats.jumpForce;
                                this.dunkRange = stats.dunkRange;
                                this.stealChance = stats.stealChance;
                                this.accuracy = stats.accuracy;

                                // State
                                this.hasBall = false;
                                this.isDunking = false;
                                this.stunned = 0;
                                this.consecutiveShots = 0;
                                this.onFire = false;
                                this.stealCooldown = 0;
                            }

                            reset() {
                                this.x = this.startX;
                                this.y = GROUND_Y - this.height;
                                this.vx = 0;
                                this.vy = 0;
                                this.hasBall = false;
                                this.isDunking = false;
                                this.stunned = 0;
                            }

                            update() {
                                if (this.stunned > 0) {
                                    this.stunned--;
                                    this.x += this.vx;
                                    this.vx *= FRICTION;
                                    this.vy += GRAVITY;
                                    this.y += this.vy;
                                    if (this.y + this.height > GROUND_Y) {
                                        this.y = GROUND_Y - this.height;
                                        this.vy = 0;
                                    }
                                    return;
                                }

                                if (this.stealCooldown > 0) this.stealCooldown--;

                                if (this.isDunking) {
                                    // Dunk physics are scripted
                                    this.x += this.vx;
                                    this.y += this.vy;
                                    this.vy += GRAVITY * 0.5; // Lower gravity during dunk for float
                                } else {
                                    // Normal physics
                                    this.vy += GRAVITY;
                                    this.x += this.vx;
                                    this.y += this.vy;
                                    this.vx *= FRICTION;
                                }

                                // Ground collision
                                if (this.y + this.height > GROUND_Y) {
                                    this.y = GROUND_Y - this.height;
                                    this.vy = 0;
                                    this.isGrounded = true;
                                    this.isDunking = false;
                                } else {
                                    this.isGrounded = false;
                                }

                                // Walls
                                if (this.x < 0) this.x = 0;
                                if (this.x > GAME_WIDTH - this.width) this.x = GAME_WIDTH - this.width;

                                // Fire logic
                                if (this.consecutiveShots >= 3) {
                                    this.onFire = true;
                                    ball.onFire = this.hasBall;
                                    this.speed = this.stats.speed * 1.4;
                                } else {
                                    this.onFire = false;
                                    this.speed = this.stats.speed;
                                }
                            }

                            move(dir) {
                                if (this.stunned > 0 || this.isDunking) return;
                                this.vx += dir * (this.speed * 0.2);
                                if (Math.abs(this.vx) > this.speed) this.vx = (this.vx > 0 ? 1 : -1) * this.speed;

                                if (dir > 0) this.facingRight = true;
                                if (dir < 0) this.facingRight = false;
                            }

                            jump() {
                                if (this.isGrounded && this.stunned <= 0 && !this.isDunking) {
                                    this.vy = -this.jumpForce;
                                    for (let i = 0; i < 5; i++) {
                                        state.particles.push(new Particle(this.x + this.width / 2, this.y + this.height, '#fff', 3, 10));
                                    }
                                }
                            }

                            shoot() {
                                if (!this.hasBall || this.stunned > 0 || this.isDunking) return;

                                let targetHoop = (this.id === 1) ? hoops[1] : hoops[0];
                                let distToHoop = Math.abs(this.x - targetHoop.x);

                                // Dunk Logic
                                // Must be in air or just starting jump, moving towards hoop, and within range
                                let movingTowards = (this.id === 1 && this.vx > 0) || (this.id === 2 && this.vx < 0);

                                if (distToHoop < this.dunkRange && movingTowards && this.y < GROUND_Y - 20) {
                                    this.performDunk(targetHoop);
                                } else {
                                    this.performShot(targetHoop);
                                }
                            }

                            performDunk(hoop) {
                                this.isDunking = true;
                                // Calculate velocity to reach hoop
                                let dir = (hoop.x > this.x) ? 1 : -1;
                                let dist = Math.abs(hoop.x - this.x);

                                // Launch towards hoop
                                this.vx = dir * (dist / 20); // Reach in approx 20 frames
                                this.vy = -10; // Jump up

                                // Schedule slam
                                setTimeout(() => {
                                    if (this.isDunking && this.hasBall && !state.isScoring) {
                                        this.dropBall();
                                        ball.x = hoop.x + 20;
                                        ball.y = hoop.y - 10;
                                        ball.vx = 0;
                                        ball.vy = 20; // Fast slam

                                        state.screenShake = 15;
                                        showMessage("BOOM!");
                                        for (let i = 0; i < 20; i++) {
                                            state.particles.push(new Particle(hoop.x + 20, hoop.y, '#FFA500', 8, 30));
                                        }
                                    }
                                }, 400); // 400ms delay for slam
                            }

                            performShot(hoop) {
                                this.dropBall();

                                let dx = (hoop.x + 20) - ball.x;
                                let dy = (hoop.y) - ball.y;

                                let powerX = dx * 0.055 + (this.vx * 0.5);
                                let powerY = -15 + (dy * 0.02);

                                let variance = this.onFire ? 0 : (1 - this.accuracy) * 4;
                                powerX += (Math.random() - 0.5) * variance;
                                powerY += (Math.random() - 0.5) * variance;

                                ball.vx = powerX;
                                ball.vy = powerY;
                                ball.isShot = true;
                            }

                            steal(target) {
                                if (this.stealCooldown > 0 || this.hasBall || !target.hasBall || state.isScoring || target.isDunking) return;

                                let dist = Math.abs(this.x - target.x);
                                let yDist = Math.abs(this.y - target.y);

                                if (dist < 60 && yDist < 50) {
                                    this.vx = this.facingRight ? 10 : -10; // Lunge

                                    if (Math.random() < this.stealChance) {
                                        target.dropBall();
                                        target.stunned = 40;
                                        this.takeBall();
                                        showMessage("STOLEN!");
                                        state.screenShake = 5;
                                    } else {
                                        this.stealCooldown = 60;
                                    }
                                }
                            }

                            takeBall() {
                                if (ball.owner) ball.owner.hasBall = false;
                                this.hasBall = true;
                                ball.owner = this;
                                ball.isShot = false;
                            }

                            dropBall() {
                                this.hasBall = false;
                                ball.owner = null;
                            }

                            draw(ctx) {
                                ctx.save();

                                // Shadow
                                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                                ctx.beginPath();
                                ctx.ellipse(this.x + this.width / 2, GROUND_Y, 20, 5, 0, 0, Math.PI * 2);
                                ctx.fill();

                                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                                if (Math.abs(this.vx) > 0.5 && this.isGrounded) {
                                    ctx.rotate(Math.sin(Date.now() / 100) * 0.1);
                                }

                                if (this.stunned > 0) ctx.globalAlpha = 0.5;

                                // Jersey
                                ctx.fillStyle = this.color;
                                if (this.onFire) {
                                    ctx.shadowBlur = 20;
                                    ctx.shadowColor = this.color;
                                }
                                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

                                // Head
                                ctx.fillStyle = '#5c4033';
                                ctx.beginPath();
                                ctx.arc(0, -this.height / 2 - 10, 15, 0, Math.PI * 2);
                                ctx.fill();

                                // Number
                                ctx.fillStyle = 'white';
                                ctx.font = 'bold 12px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText("23", 0, 0);

                                // Shoes
                                ctx.fillStyle = (this.id === 2) ? '#333' : '#eee'; // MJ wears black shoes
                                ctx.fillRect(-this.width / 2, this.height / 2 - 10, 12, 10);
                                ctx.fillRect(this.width / 2 - 12, this.height / 2 - 10, 12, 10);

                                ctx.restore();
                            }
                        }

                        // --- Objects ---

                        const lebron = new Player(1, "LeBron", "#552583", 200, {
                            speed: 10,
                            jumpForce: 18,
                            dunkRange: 250,
                            stealChance: 0.7,
                            accuracy: 0.95
                        });

                        const jordan = new Player(2, "Jordan", "#CE1141", 600, {
                            speed: 7,
                            jumpForce: 14,
                            dunkRange: 120,
                            stealChance: 0.4,
                            accuracy: 0.7
                        });

                        const ball = new Ball();

                        const hoops = [
                            { x: 40, y: 280, isLeft: true, scoredRecently: false },
                            { x: 720, y: 280, isLeft: false, scoredRecently: false }
                        ];

                        // --- AI Logic ---
                        function updateAI() {
                            const ai = jordan;
                            const opponent = lebron;

                            // AI is simpler, reacts occasionally
                            if (state.gameOver || state.isScoring || Math.random() < 0.05) return;

                            if (ai.hasBall) {
                                // Offense: Move left
                                let targetX = hoops[0].x + 40;

                                if (ai.x > targetX) ai.move(-1);
                                else if (ai.x < targetX - 20) ai.move(1);

                                let dist = Math.abs(ai.x - targetX);
                                if (dist < 150) {
                                    // Shoot or Dunk
                                    if (Math.random() < 0.08) ai.shoot();
                                } else if (Math.abs(ai.x - opponent.x) < 60 && Math.random() < 0.05) {
                                    // Jump over defender
                                    ai.jump();
                                }

                            } else {
                                // Defense
                                if (ball.owner === opponent) {
                                    let dir = (opponent.x > ai.x) ? 1 : -1;
                                    ai.move(dir);

                                    // Steal Attempt
                                    if (Math.abs(ai.x - opponent.x) < 50 && Math.abs(ai.y - opponent.y) < 50) {
                                        if (Math.random() < 0.03) ai.steal(opponent);
                                    }

                                    // Block Attempt
                                    if (opponent.vy < 0 && Math.abs(ai.x - opponent.x) < 50 && opponent.hasBall) {
                                        if (ai.isGrounded && Math.random() < 0.15) ai.jump();
                                    }
                                } else {
                                    // Chase loose ball
                                    let dir = (ball.x > ai.x) ? 1 : -1;
                                    ai.move(dir);
                                    // Jump for high ball
                                    if (ball.y < ai.y - 50 && Math.abs(ball.x - ai.x) < 30 && ai.isGrounded) ai.jump();
                                }
                            }
                        }

                        // --- Core Game Functions ---

                        function scorePoint(playerId) {
                            if (state.isScoring) return;

                            state.isScoring = true; // Pause game

                            if (playerId === 1) {
                                state.p1Score += 2;
                                document.getElementById('score-p1').innerText = state.p1Score;
                                lebron.consecutiveShots++;
                                jordan.consecutiveShots = 0;

                                let msg = lebron.consecutiveShots >= 3 ? "HE'S ON FIRE!" : "LEBRON SCORES!";
                                showMessage(msg);

                            } else {
                                state.p2Score += 2;
                                document.getElementById('score-p2').innerText = state.p2Score;
                                jordan.consecutiveShots++;
                                lebron.consecutiveShots = 0;

                                let msg = jordan.consecutiveShots >= 3 ? "MJ HEATING UP!" : "JORDAN SCORES!";
                                showMessage(msg);
                            }

                            // Reset positions after delay
                            setTimeout(resetPos, 1500);
                        }

                        function resetPos() {
                            state.isScoring = false;
                            hoops.forEach(h => h.scoredRecently = false);

                            lebron.reset();
                            jordan.reset();

                            // Jump Ballish restart
                            ball.x = GAME_WIDTH / 2;
                            ball.y = 200;
                            ball.vx = 0;
                            ball.vy = -5;
                            ball.owner = null;
                            ball.isShot = false;
                            ball.onFire = false;

                            // Clear particles
                            state.particles = [];
                        }

                        function showMessage(text) {
                            const el = document.getElementById('message-overlay');
                            el.innerHTML = text;
                            el.style.display = 'block';
                            el.className = "pop-anim";
                            if (text.includes("FIRE")) el.classList.add("fire-text");

                            setTimeout(() => {
                                el.style.display = 'none';
                                el.classList.remove("fire-text");
                            }, 1500);
                        }

                        function update() {
                            // Screen shake recovery
                            if (state.screenShake > 0) {
                                state.camera.x = (Math.random() - 0.5) * state.screenShake;
                                state.camera.y = (Math.random() - 0.5) * state.screenShake;
                                state.screenShake *= 0.9;
                                if (state.screenShake < 1) state.screenShake = 0;
                            } else {
                                state.camera.x = 0;
                                state.camera.y = 0;
                            }

                            if (state.gameOver) {
                                if (KEYS['KeyZ']) {
                                    // Restart
                                    state.p1Score = 0;
                                    state.p2Score = 0;
                                    state.timeLeft = 120;
                                    state.gameOver = false;
                                    document.getElementById('score-p1').innerText = "0";
                                    document.getElementById('score-p2').innerText = "0";
                                    document.getElementById('message-overlay').style.display = 'none';
                                    resetPos();
                                }
                                return;
                            }

                            // Input - P1
                            if (KEYS['ArrowLeft']) lebron.move(-1);
                            else if (KEYS['ArrowRight']) lebron.move(1);

                            // Input Handling
                            if (KEYS['KeyZ']) {
                                if (lebron.hasBall) {
                                    lebron.shoot();
                                } else {
                                    lebron.jump();
                                }
                                KEYS['KeyZ'] = false; // Debounce
                            }

                            if (KEYS['KeyX']) {
                                lebron.steal(jordan);
                                KEYS['KeyX'] = false;
                            }

                            if (!state.isScoring) {
                                updateAI();
                                lebron.update();
                                jordan.update();
                                ball.update();

                                // Ball pickup collision
                                if (!ball.owner) {
                                    [lebron, jordan].forEach(p => {
                                        // Increased pickup range
                                        if (Math.abs(ball.x - (p.x + p.width / 2)) < 40 &&
                                            Math.abs(ball.y - (p.y + p.height / 2)) < 60 &&
                                            p.stunned <= 0 && !p.isDunking) {
                                            p.takeBall();
                                        }
                                    });
                                }
                            } else {
                                // Just animate particles during score celebration
                            }

                            // Particles always update
                            for (let i = state.particles.length - 1; i >= 0; i--) {
                                state.particles[i].update();
                                if (state.particles[i].life <= 0) state.particles.splice(i, 1);
                            }
                        }

                        function drawCourt(ctx) {
                            ctx.fillStyle = '#cfb53b';
                            ctx.fillRect(0, GROUND_Y, GAME_WIDTH, GAME_HEIGHT - GROUND_Y);
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(0, GROUND_Y);
                            ctx.lineTo(GAME_WIDTH, GROUND_Y);
                            ctx.stroke();

                            // Key areas
                            ctx.strokeRect(0, GROUND_Y, 120, GAME_HEIGHT - GROUND_Y);
                            ctx.strokeRect(GAME_WIDTH - 120, GROUND_Y, 120, GAME_HEIGHT - GROUND_Y);
                        }

                        function drawHoop(ctx, hoop) {
                            ctx.fillStyle = '#555';
                            let poleX = hoop.isLeft ? hoop.x - 20 : hoop.x + 40 + 20;
                            ctx.fillRect(poleX, hoop.y - 50, 10, GROUND_Y - (hoop.y - 50));

                            ctx.fillStyle = 'rgba(255,255,255,0.8)';
                            ctx.fillRect(hoop.x, hoop.y - 50, 40, 50);

                            // Rim
                            ctx.strokeStyle = '#ff4500';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            let rimStart = hoop.isLeft ? hoop.x + 40 : hoop.x;
                            let rimEnd = hoop.isLeft ? hoop.x + 70 : hoop.x - 30;
                            ctx.moveTo(rimStart, hoop.y);
                            ctx.lineTo(rimEnd, hoop.y);
                            ctx.stroke();

                            // Net
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(rimStart, hoop.y);
                            ctx.lineTo((rimStart + rimEnd) / 2, hoop.y + 25);
                            ctx.lineTo(rimEnd, hoop.y);
                            ctx.stroke();
                        }

                        function draw() {
                            ctx.save();
                            ctx.translate(state.camera.x, state.camera.y);

                            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                            drawCourt(ctx);

                            // Crowd
                            ctx.fillStyle = '#222';
                            for (let i = 0; i < GAME_WIDTH; i += 40) {
                                ctx.fillRect(i, 300, 30, 20);
                                ctx.fillRect(i + 20, 260, 20, 20);
                            }

                            hoops.forEach(h => drawHoop(ctx, h));

                            // Draw players behind ball if ball is "shot" close to camera? No, standard layer
                            lebron.draw(ctx);
                            jordan.draw(ctx);
                            ball.draw(ctx);

                            state.particles.forEach(p => p.draw(ctx));

                            ctx.restore();
                        }

                        function gameLoop() {
                            update();
                            draw();

                            if (!state.gameOver && !state.isScoring) {
                                // Timer only ticks during active play
                                if (Math.random() < (1 / 60)) {
                                    state.timeLeft -= 1;
                                    let m = Math.floor(state.timeLeft / 60);
                                    let s = Math.floor(state.timeLeft % 60);
                                    document.getElementById('timer').innerText = `0${m}:${s < 10 ? '0' : ''}${s}`;

                                    if (state.timeLeft <= 0) {
                                        state.gameOver = true;
                                        let msg = "";
                                        if (state.p1Score > state.p2Score) msg = "LEBRON WINS!";
                                        else if (state.p2Score > state.p1Score) msg = "JORDAN WINS!";
                                        else msg = "DRAW GAME!";

                                        showMessage(msg + "<br><span class='restart-msg'>Press Z to Restart</span>");
                                        // Override the timeout hide
                                        document.getElementById('message-overlay').style.display = 'block';
                                    }
                                }
                            }

                            requestAnimationFrame(gameLoop);
                        }

        // Start
        ball.vy = -10;
        gameLoop();
    </script>
</body>

</html>